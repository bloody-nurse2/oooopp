
### **1. Классы**

**1.1. Что такое класс?**  
Класс — это шаблон (тип) для создания объектов. Определяет данные (поля) и действия (методы), которые объект может выполнять.

**1.2. Поля и методы класса**  
- **Поля** — переменные внутри класса (состояние объекта).  
- **Методы** — функции внутри класса (поведение объекта).

**1.3. Конструктор класса**  
Специальный метод с именем как у класса, вызывается при создании объекта. Используется для инициализации полей.

**1.4. Конструктор по умолчанию**  
Конструктор без параметров. Если не написать ни одного конструктора — компилятор добавит его автоматически.

**1.5. Обращение к функционалу класса**  
Через объект: `объект.метод()` или `объект.поле`.

**1.6. Ключевое слово `this`**  
Ссылка на текущий экземпляр класса. Используется, чтобы отличить поля от параметров с одинаковыми именами.

**1.7. Цепочка вызова конструкторов**  
Один конструктор вызывает другой с помощью `: this(...)` в объявлении. Позволяет избежать дублирования кода.

**1.8. Инициатор объекта (object initializer)**  
Синтаксис после `new`, позволяющий сразу задать значения публичных полей/свойств:  
```csharp
var obj = new MyClass { Field = 5 };
```

**1.9. Деконструктор**  
Метод с именем `Deconstruct`, позволяет "распаковать" объект в несколько переменных:  
```csharp
var (x, y) = point;
```

**Пример реализации:**
```csharp
class Person {
    public string Name;
    public int Age;

    public Person() { } // конструктор по умолчанию

    public Person(string name) : this() {
        Name = name; // this не обязателен, но можно
    }

    public void SayHi() => Console.WriteLine($"Hi, I'm {Name}");
}

// Создание и использование:
Person p = new Person("Alice");
p.SayHi(); // вызов метода
```

---

### **2. Структуры**

**2.1. Структура и отличие от класса**  
- **Структура (`struct`)** — тип значения (value type).  
- **Класс (`class`)** — тип ссылки (reference type).  
→ При присваивании структура копируется, класс — передаётся ссылка.

**2.2. Инициализация через конструктор**  
Как и у класса, но **все поля должны быть инициализированы в конструкторе**.

**2.3. Инициализация полей напрямую**  
Можно задавать значения при объявлении полей:  
```csharp
public struct Point {
    public int X = 0;
    public int Y = 0;
}
```

**2.4. Особенности конструктора структуры**  
- Нельзя определить конструктор без параметров (если явно — ошибка).  
- Всегда есть неявный конструктор по умолчанию (обнуляет поля).

**2.5. Инициатор структуры**  
Тот же синтаксис, что и у класса:  
```csharp
var p = new Point { X = 1, Y = 2 };
```

**2.6. Ключевое слово `with`**  
Создаёт **копию** структуры с изменёнными полями (только для `readonly struct` или записей `record struct`):  
```csharp
var p2 = p with { X = 10 };
```

**Пример:**
```csharp
struct Point {
    public int X;
    public int Y;

    public Point(int x, int y) {
        X = x;
        Y = y;
    }
}

Point a = new Point(1, 2);
Point b = a; // копия
b.X = 10;    // a.X остаётся 1
```



---

### **3. Область видимости**

**3.1. Что такое область видимости? Какие бывают?**  
Область видимости — участок кода, где переменная или константа доступна.  
Виды:
- **Локальная** — внутри метода/блока (`{}`).
- **Классовая** — поля и свойства класса (доступны во всех методах класса).
- **Глобальная** — в C# нет глобальных переменных, но есть статические члены класса (доступны через имя класса).

Пример:
```csharp
class A {
    int x; // область видимости — весь класс

    void M() {
        int y = 5; // область видимости — только внутри M()
    }
}
```

---

### **4. Модификаторы доступа**

**4.1. Что такое модификаторы доступа? Какие бывают?**  
Определяют, откуда можно обращаться к члену (полю, методу и т.д.) или типу.

Модификаторы:
- `public` — доступен отовсюду.
- `private` — только внутри своего класса.
- `protected` — внутри своего класса и производных.
- `internal` — внутри одной сборки (проекта).
- `protected internal` — комбинация `protected` + `internal`.
- `private protected` — только в производных классах **в той же сборке**.

По умолчанию:
- Для **классов/структур** — `internal`.
- Для **членов класса** — `private`.

Пример:
```csharp
class BankAccount {
    private decimal balance; // только внутри класса
    public string Owner { get; set; } // везде
}
```

---

### **5. Свойства**

**5.1. Что такое свойство? Чем отличается от поля?**  
Свойство — это метод с синтаксисом как поле. Позволяет контролировать чтение/запись.  
Поле — просто переменная.  
→ Свойства безопаснее и гибче.

**5.2. Свойства только для чтения/записи**  
- Только чтение: `get;` без `set;`  
- Только запись: `set;` без `get;` (редко используется)

**5.3. Вычисляемые свойства**  
Не хранят значение, а вычисляют его при обращении:
```csharp
public double Area => Width * Height;
```

**5.4. Модификаторы доступа в свойствах**  
Можно задавать разный доступ для `get` и `set`:
```csharp
public string Name { get; private set; }
```

**5.5. Автоматические свойства**  
Сокращённая запись без явного поля:
```csharp
public int Age { get; set; }
```
Компилятор сам создаёт скрытое поле.

**5.6. Блок `init`**  
Разрешает установку значения **только при инициализации объекта** (через инициатор или конструктор):
```csharp
public string Name { get; init; }
// var p = new Person { Name = "Alice" }; // OK
// p.Name = "Bob"; // ошибка
```

**5.7. Сокращённая запись свойств**  
Через выражение:
```csharp
public string FullName => $"{FirstName} {LastName}";
```

**5.8. Модификатор `required`**  
Указывает, что свойство **обязательно** должно быть установлено при создании объекта (иначе ошибка компиляции):
```csharp
public required string Title { get; set; }
// new Book(); // ошибка
// new Book { Title = "C#" }; // OK
```

**Пример комплексный:**
```csharp
class Person {
    public string Name { get; init; }          // задаётся один раз
    public required int Id { get; set; }       // обязательно при создании
    public int Age { get; set; }
    public string Info => $"ID: {Id}, {Name}"; // вычисляемое
}

// Использование:
var p = new Person { Name = "Alice", Id = 1 };
```

---



### **6. Перегрузка методов** *(overloading)*

**6.1. Что такое перегрузка методов? Для чего применяется?**  
Это создание **нескольких методов с одним именем**, но **разными параметрами**.  
Нужна для удобства: один смысл — разные способы вызова.

**6.2. Как реализуется?**  
Меняются:
- количество параметров,
- типы параметров,
- порядок параметров (если типы разные).

**НЕЛЬЗЯ** перегружать только по возвращаемому типу или по `ref`/`out`.

**6.3. Сигнатура метода**  
Это имя метода + список типов параметров (без имён и без возвращаемого типа).  
Перегрузка возможна **только при разных сигнатурах**.

**Пример:**
```csharp
void Print(string s) => Console.WriteLine(s);
void Print(int n) => Console.WriteLine(n);
void Print(string s, int n) => Console.WriteLine($"{s}: {n}");
```
Все три — разные сигнатуры → допустимо.

---

### **7. Статические члены**

**Общее правило:**  
Статические члены принадлежат **типу**, а не экземпляру. Вызываются через имя класса, **без создания объекта**.

**7.1. Статические поля**  
Хранят данные, общие для всех объектов класса.  
Пример: счётчик созданных объектов.
```csharp
public static int Count = 0;
```

**7.2. Статические свойства**  
Дают контролируемый доступ к статическим данным.
```csharp
public static int Total => Count;
```

**7.3. Статические методы**  
Работают без объекта. Не имеют доступа к `this` и нестатическим членам.  
Пример: `Math.Sqrt(4)`.

**7.4. Статический конструктор**  
Вызывается **один раз** при первом обращении к типу. Используется для инициализации статических полей.  
- Без параметров.
- Нельзя вызвать вручную.
```csharp
static MyClass() {
    // инициализация
}
```

**7.5. Статический класс**  
Класс, помеченный `static`.  
Особенности:
- нельзя создавать экземпляры (`new` запрещён),
- может содержать **только статические члены**,
- часто используется для утилит (например, `Math`, `Console`).

**Пример:**
```csharp
public static class Logger {
    public static void Log(string msg) => Console.WriteLine(msg);
}

// Использование:
Logger.Log("Hello"); // без new!
```

---


### **8. Константы, поля и структуры для чтения**

**8.1. Что такое константы класса?**  
`const` — поле, значение которого **известно на этапе компиляции** и **не может меняться**.  
Всегда неявно `static`.  
Пример:  
```csharp
public const double Pi = 3.14159;
```

**8.2. Модификатор `readonly`**  
Поле можно инициализировать:
- при объявлении,
- в конструкторе.  
После — только чтение.  
Подходит для значений, известных **во время выполнения**.  
Пример:  
```csharp
public readonly DateTime CreationTime = DateTime.Now;
```

**8.3. Сравнение констант**  
Константы сравниваются **по значению**, как обычные литералы.  
Так как они compile-time, сравнение происходит на этапе компиляции (если возможно).

**8.4. Структуры для чтения (`readonly struct`)**  
Гарантирует, что **все поля структуры неизменяемы**.  
Повышает производительность (компилятор может избежать копирования).  
Пример:  
```csharp
public readonly struct Point {
    public int X { get; }
    public int Y { get; }
    public Point(int x, int y) => (X, Y) = (x, y);
}
```

---

### **9. Null и ссылочные типы**

> ⚠️ В C# 8+ включён **nullable reference types** по умолчанию в новых проектах.

**9.1. Отключение nullable-контекста**  
Добавить в файл:  
```csharp
#nullable disable
```  
Или в проекте: `<Nullable>disable</Nullable>`.

**9.2. Оператор `!` (null-forgiving)**  
Говорит компилятору: «Я уверен, что это не null».  
Используется, если компилятор ругается, а вы знаете, что значение безопасно.  
Пример:  
```csharp
string? s = GetText();
string t = s!; // отключает предупреждение
```

---

### **10. Null и значимые типы**

Значимые типы (`int`, `bool`, `struct`) **не могут быть null** — но есть обёртка: **`Nullable<T>`** или сокращённо **`T?`**.

**10.1. `Value`, `HasValue`, `GetValueOrDefault()`**  
Для `int? x = 5;`:
- `x.HasValue` → `true`
- `x.Value` → `5` (падает, если null)
- `x.GetValueOrDefault()` → `5` (или `0`, если null)

**10.2. Преобразование `T?` ↔ `T`**  
- Неявно: `int? → object` — OK.  
- Явно: `int? → int` — только если не null, иначе исключение.  
- Безопасно: через `??` или проверку `HasValue`.

**10.3. Проверка на null — варианты:**  
```csharp
if (x == null) ...
if (x is null) ...
if (!x.HasValue) ... // для T?
```

**10.4. Оператор `?`**  
Используется в трёх формах:
- `T?` — объявление nullable-типа (`int?`)
- `?.` — условный вызов (см. 10.7)
- `??` — оператор объединения с null (см. 10.5)

**10.5. Оператор `??`**  
Возвращает левое значение, если оно не null, иначе — правое:  
```csharp
int result = x ?? 0;
```

**10.6. Null guard**  
Проверка в начале метода, чтобы избежать `NullReferenceException`:  
```csharp
void Process(string s) {
    if (s is null) throw new ArgumentNullException(nameof(s));
    // ...
}
```

**10.7. Оператор условного null (`?.`)**  
Вызывает метод/доступ к свойству **только если объект не null**:  
```csharp
int? length = text?.Length; // если text == null → length = null
list?.Add(item); // вызовет Add, только если list != null
```

**Пример комплексный:**
```csharp
int? a = null;
int b = a ?? -1;           // b = -1
Console.WriteLine(a?.ToString() ?? "пусто"); // "пусто"
```

---


### **11. Наследование**

**11.1. Как выполнить наследование? Для чего используется?**  
- **Классы**: `class Child : Parent` — наследуют поведение и данные.  
- **Структуры**: **НЕ МОГУТ наследоваться** (кроме от `System.ValueType`, но это скрыто).  
→ Наследование нужно для **расширения функционала** и **повторного использования кода**.

**11.2. Доступ к членам базового класса**  
- Доступны члены с модификаторами `public`, `protected`, `internal` (в зависимости от сборки).  
- `private` — недоступны.

**11.3. Ключевое слово `base`**  
Используется для:
- вызова конструктора базового класса: `: base(...)`
- обращения к методам/полям базового класса: `base.Method()`

**11.4. Порядок вызова конструкторов**  
Сначала вызывается **конструктор базового класса**, потом — производного.  
Если в производном нет `: base(...)`, вызывается **конструктор по умолчанию** базового.

**Пример:**
```csharp
class Animal {
    public Animal() => Console.WriteLine("Animal");
}

class Dog : Animal {
    public Dog() : base() => Console.WriteLine("Dog");
}

// new Dog(); → вывод: Animal, Dog
```

> ⚠️ Все классы в C# неявно наследуются от `object`.

---

### **12. Преобразование типов**

**12.1. Восходящее преобразование (upcasting)**  
Преобразование **от потомка к предку**.  
**Безопасно**, делается **неявно**:  
```csharp
Dog d = new Dog();
Animal a = d; // OK
```

**12.2. Нисходящее преобразование (downcasting)**  
Преобразование **от предка к потомку**.  
**Небезопасно**, требует **явного приведения** или проверки:  
```csharp
Animal a = new Dog();
Dog d = (Dog)a; // может упасть, если a — не Dog
```

**12.3. Способы преобразования:**
1. **Явное приведение**: `(Dog)a` — падает при ошибке.
2. **`as`** — безопасно, возвращает `null` при неудаче (только для ссылочных типов):  
   ```csharp
   Dog d = a as Dog;
   ```
3. **`is`** — проверка типа:  
   ```csharp
   if (a is Dog) { ... }
   ```
4. **Pattern matching** (C# 7+):  
   ```csharp
   if (a is Dog d) { /* d уже приведён */ }
   ```

**Особенности:**
- Значимые типы можно приводить только явно (`(int)5.7`).
- Для пользовательских преобразований — `implicit`/`explicit` операторы.

**Пример:**
```csharp
object o = "text";
if (o is string s) {
    Console.WriteLine(s.Length); // s уже string
}
```



---

### **13. Виртуальные методы и свойства**

**13.1. Виртуальные методы**  
Методы, помеченные `virtual` в базовом классе. Их можно **переопределить** (`override`) в потомке для полиморфного поведения.

**13.2. Виртуальные свойства**  
Свойства с модификатором `virtual`. Также можно переопределять через `override`.

**13.3. Способы переопределения**  
- Использовать `override` в производном классе.  
- Метод/свойство в базовом классе **должно быть** `virtual`, `abstract` или `override`.

**13.4. Переопределение свойств**  
Точно так же, как методы:
```csharp
public override string Name { get => base.Name.ToUpper(); }
```

**13.5. Запрет переопределения**  
Использовать `sealed` при переопределении:
```csharp
public sealed override void Speak() { }
```
→ Дальнейшее переопределение запрещено.

**Пример:**
```csharp
class Animal {
    public virtual void Speak() => Console.WriteLine("...");
}

class Dog : Animal {
    public override void Speak() => Console.WriteLine("Гав!");
    
    public sealed override void Eat() => Console.WriteLine("Ест");
}
```

> `base` внутри `override` вызывает реализацию из базового класса.

---

### **14. Скрытие методов и свойств**

**14.1. Чем скрытие отличается от переопределения?**  
- **Переопределение (`override`)** — полиморфизм: вызывается метод **реального типа объекта**.  
- **Скрытие (`new`)** — нет полиморфизма: вызывается метод **типа переменной**.

**14.2. Способы сокрытия**  
Использовать ключевое слово `new` в производном классе:
```csharp
public new void Method() { ... }
```
→ Скрывает метод с тем же именем в базовом классе.

**14.3. Скрытие переменных и констант**  
Поля и константы **не участвуют в виртуальном вызове**, поэтому их "скрытие" происходит **автоматически**, если объявить поле с тем же именем в потомке.  
Но лучше **не делать так** — это путает.

**Пример различия:**
```csharp
class A {
    public virtual void M() => Console.WriteLine("A");
    public void N() => Console.WriteLine("A.N");
}

class B : A {
    public override void M() => Console.WriteLine("B");   // переопределение
    public new void N() => Console.WriteLine("B.N");     // скрытие
}

A obj = new B();
obj.M(); // B (полиморфизм)
obj.N(); // A.N (нет полиморфизма → вызов по типу переменной)
```

> Скрытие — редко используется. Лучше — `virtual`/`override` или интерфейсы.

---


### **15. Абстрактные классы и члены**

**15.1. Абстрактный класс**  
Класс, помеченный `abstract`. **Нельзя создавать объекты** этого класса. Используется как базовый для наследников.

**15.2. Абстрактный метод**  
Метод без реализации:  
```csharp
public abstract void Draw();
```
→ Должен быть реализован (`override`) в **неабстрактном** потомке.

**15.3. Абстрактное свойство**  
Свойство без `get`/`set`-тела:  
```csharp
public abstract string Name { get; }
```

**15.4. Отказ от реализации абстрактных членов**  
Можно **только если сам класс тоже `abstract`**. Тогда ответственность передаётся дальше по цепочке наследования.

**Пример:**
```csharp
abstract class Shape {
    public abstract double Area { get; }
}

class Circle : Shape {
    public override double Area => Math.PI * Radius * Radius;
}
```

> Если не реализовать абстрактный член в неабстрактном классе — ошибка компиляции.

---

### **16. Обобщения (Generics)**

**16.1. Что такое обобщение?**  
Механизм, позволяющий писать код **без привязки к конкретному типу**. Тип указывается при использовании.

**16.2. Применение**  
Используются для коллекций, алгоритмов, утилит — чтобы работать с любыми типами безопасно и без приведений.

**16.3. Несколько универсальных параметров**  
Указываются через запятую:  
```csharp
class Pair<T, U> { public T First; public U Second; }
```

**16.4. Обобщённые методы**  
Метод может иметь свои параметры типов:
```csharp
static void Swap<T>(ref T a, ref T b) { ... }
```

**Дополнительно:**
- В **статических классах** — только обобщённые методы (сам класс не может быть `static` + `generic`).
- При **наследовании**: можно наследоваться от обобщённого класса, подставив тип или оставив параметр:
  ```csharp
  class IntList : List<int> { }
  class MyList<T> : List<T> { }
  ```

**Пример:**
```csharp
var list = new List<string>();
list.Add("Hello");

Swap(ref x, ref y); // работает с любым типом
```

---

### **17. Ограничения обобщений**

**17.1. Зачем нужны ограничения?**  
Чтобы гарантировать, что тип-параметр имеет нужные свойства (методы, конструктор и т.д.).

**17.2. Ограничения в методах**  
После списка параметров:
```csharp
void M<T>(T item) where T : class, new() { }
```

**17.3. Ограничения в типах**  
Аналогично, после объявления класса/структуры:
```csharp
class Box<T> where T : IComparable<T> { }
```

**17.4. Типы ограничений:**
- `where T : class` — только ссылочные типы  
- `where T : struct` — только значимые типы  
- `where T : new()` — должен иметь конструктор без параметров  
- `where T : BaseClass` — должен наследоваться от указанного класса  
- `where T : ISomeInterface` — должен реализовывать интерфейс  

**17.5. Несколько ограничений**  
Перечисляются через запятую:
```csharp
where T : class, ICloneable, new()
```

**17.6. Наследование обобщённых типов**  
- Можно наследоваться от обобщённого типа, **подставив конкретный тип** или **оставив параметр**.
- Ограничения **не наследуются автоматически**, но должны соблюдаться.

**Пример:**
```csharp
public static T Create<T>() where T : new() => new T();

// Использование:
var obj = Create<MyClass>(); // MyClass должен иметь конструктор без параметров
```

> Без ограничений внутри обобщённого кода нельзя вызывать методы, кроме тех, что есть у `object`.

---


### **18. Обработка исключений**

**18.1. `try..catch..finally`**  
- `try` — код, где может возникнуть ошибка.  
- `catch` — обрабатывает исключение.  
- `finally` — выполняется **всегда**, даже если было исключение или `return`.

**18.2. Блок `catch`**  
Определяется с указанием типа исключения (обычно от `Exception`):  
```csharp
catch (ArgumentNullException ex) { ... }
catch (Exception ex) { ... } // ловит всё остальное
```
→ Блоки идут **от конкретного к общему**.

**18.3. Фильтры исключений**  
Позволяют добавить условие через `when`:  
```csharp
catch (Exception ex) when (ex.Message.Contains("file")) {
    // обрабатываем только если в сообщении "file"
}
```

**Пример:**
```csharp
try {
    File.ReadAllText("missing.txt");
} 
catch (FileNotFoundException ex) when (ex.FileName.EndsWith(".txt")) {
    Console.WriteLine("Текстовый файл не найден");
} 
finally {
    Console.WriteLine("Завершено");
}
```

> ⚠️ Исключения — для **аварийных ситуаций**, а не для управления логикой (в отличие от `if`).

---

### **19. Особенности работы с исключениями**

**19.1. Оператор `throw`**  
- Генерирует исключение:  
  ```csharp
  throw new ArgumentException("Неверный аргумент");
  ```
- В `catch` можно **повторно выбросить** то же исключение:  
  ```csharp
  catch (Exception) {
      Log();
      throw; // сохраняет стек вызовов
  }
  ```

**19.2. Пользовательские исключения**  
Наследуются от `Exception` (или `ApplicationException`), имя заканчивается на `Exception`:  
```csharp
public class InvalidAgeException : Exception {
    public InvalidAgeException(string message) : base(message) { }
}
```

**19.3. Поиск блока `catch`**  
Когда исключение возникает:
1. Ищется ближайший `catch` в текущем `try`.
2. Если нет — поднимается по стеку вызовов.
3. Сравнивается тип исключения с типом в `catch` (**точное совпадение или базовый класс**).
4. Выполняется **первый подходящий** блок.

**Иерархия:**  
Все исключения наследуются от `System.Exception`.  
- `SystemException` — системные ошибки.  
- `ApplicationException` — для пользовательских (но сейчас чаще наследуют напрямую от `Exception`).

**Пример:**
```csharp
void CheckAge(int age) {
    if (age < 0) throw new InvalidAgeException("Возраст не может быть отрицательным");
}

try {
    CheckAge(-5);
} 
catch (InvalidAgeException ex) {
    Console.WriteLine(ex.Message);
}
```

> Не ловите `Exception` без причины — лучше обрабатывать конкретные типы.

---



### **20. Делегаты**

**20.1. Что такое делегат?**  
Тип, который **хранит ссылку на метод** с определённой сигнатурой (тип возвращаемого значения и параметры).

**20.2. Определение делегата**  
```csharp
public delegate int MathOperation(int a, int b);
```
→ Теперь `MathOperation` — тип, которому можно присвоить любой метод с такой же сигнатурой.

**20.3. Параметры и возврат**  
Делегат вызывается **как метод**: передаёте аргументы → получаете результат.  
Сигнатура делегата должна **точно совпадать** с методом.

**20.4. Присвоение метода делегату**  
Просто указываете имя метода (без скобок):  
```csharp
MathOperation op = Add; // Add — метод с подходящей сигнатурой
```

**Пример:**
```csharp
int Add(int x, int y) => x + y;

MathOperation del = Add;
int result = del(3, 4); // 7
```

> Делегат — безопасная замена указателя на функцию.

---

### **21. Работа с делегатом**

**21.1. Добавление методов**  
Через оператор `+` или `+=`:  
```csharp
del += Subtract;
```
→ Создаётся **мультICAST-делегат** (список методов).

**21.2. Объединение делегатов**  
```csharp
MathOperation combined = op1 + op2;
```
→ При вызове выполняются **все методы по порядку**.  
→ Если есть возвращаемое значение — возвращается **только от последнего** метода.

**21.3. Вызов делегата**  
Как обычный метод:  
```csharp
del(5, 3);
```

**21.4. Делегат как параметр метода**  
Полезно для обратных вызовов (callback):  
```csharp
void Execute(MathOperation op) {
    int res = op(10, 2);
}
```

**21.5. Возврат делегата из метода**  
Можно вернуть делегат как результат:  
```csharp
MathOperation GetOperation(string type) {
    return type == "add" ? Add : Subtract;
}
```

**Пример полный:**
```csharp
delegate void Logger(string msg);

void Main() {
    Logger log = Console.WriteLine;
    log += FileLogger; // добавили второй метод

    log("Hello"); // выведет в консоль И запишет в файл
}

void FileLogger(string s) => File.WriteAllText("log.txt", s);
```

> Удаление метода: `log -= FileLogger;`

---


### **22. Анонимные методы и лямбды**

**22.1. Анонимный метод**  
Метод **без имени**, определяемый прямо при присвоении делегату.  
Синтаксис:  
```csharp
delegate void Action();
Action a = delegate { Console.WriteLine("Анонимный"); };
```

**22.2. Применение анонимного метода**  
Используется там, где нужен **одноразовый обработчик**:  
```csharp
button.Click += delegate { MessageBox.Show("Клик!"); };
```

**22.3. Лямбда-выражение**  
Более короткая и современная форма анонимного метода.  
Синтаксис:  
```csharp
(parameters) => expression
// или
(parameters) => { statements; }
```

Пример:  
```csharp
Func<int, int> square = x => x * x;
```

> Лямбды — основа LINQ и функционального стиля в C#.

---

### **23. Применение лямбда-выражений**

**23.1. Добавление/удаление действий**  
Лямбды можно добавлять в multicast-делегаты через `+=`, но **удалить — нельзя напрямую**, потому что каждая лямбда создаёт **новый объект**.  
→ Удаление работает **только если сохранить ссылку**:  
```csharp
Action handler = () => Console.WriteLine("!");
eventHandler += handler;
eventHandler -= handler; // OK
```

**23.2. Возврат результата**  
- Однострочная лямбда: `x => x * 2` — возвращает результат автоматически.  
- Блочная: `x => { return x * 2; }` — явный `return`.

**23.3. Лямбда как аргумент метода**  
Часто используется с `Func`, `Action`, LINQ:  
```csharp
var evens = list.Where(x => x % 2 == 0);
list.ForEach(x => Console.WriteLine(x));
```

**23.4. Лямбда как результат метода**  
Метод может возвращать делегат (например, `Func`):  
```csharp
Func<int, int> CreateMultiplier(int factor) => x => x * factor;
```

---

### **Стандартные делегаты в .NET**

| Делегат       | Назначение                              | Пример использования |
|---------------|----------------------------------------|----------------------|
| `Action`      | Метод без возвращаемого значения       | `Action<int> print = x => Console.WriteLine(x);` |
| `Action<T...>`| То же, с параметрами (до 16)           |                      |
| `Func<R>`     | Метод с возвращаемым значением         | `Func<int, bool> isEven = x => x % 2 == 0;` |
| `Func<T..., R>`| С параметрами и возвратом             |                      |
| `Predicate<T>`| То же, что `Func<T, bool>`             | Используется в `List.Find()` |

> Используйте `Action`/`Func` вместо своих делегатов, если сигнатура стандартная.

---

**Пример комплексный:**
```csharp
// Анонимный метод
Timer t = new Timer(delegate { Console.WriteLine("Tick"); }, null, 0, 1000);

// Лямбда
var numbers = new[] {1, 2, 3, 4};
var squares = numbers.Select(x => x * x).ToArray(); // [1, 4, 9, 16]

// Возврат лямбды
Func<int, int> doubler = CreateMultiplier(2); // из примера выше
Console.WriteLine(doubler(5)); // 10
```

---


### **24. События**

**24.1. Что такое событие?**  
Событие (`event`) — это **ограниченный делегат**, который позволяет подписываться и отписываться от уведомлений, но **нельзя вызвать извне класса**.

→ Отличие от делегата:  
- Событие можно **только += / -=** извне.  
- Вызвать (`event()`) можно **только внутри своего класса**.

**24.2. Определение и вызов события**  
```csharp
public event Action<string> MessageReceived;

// Вызов:
MessageReceived?.Invoke("Привет!");
```
→ Рекомендуется проверять на `null` (или использовать `?.`).

**24.3. Добавление обработчика**  
Через `+=`:  
```csharp
obj.MessageReceived += OnMessage;
```

**24.4. Управление обработчиками**  
- Подписка: `+=`  
- Отписка: `-=`  
→ Важно отписываться, чтобы избежать утечек памяти.

**24.5. Передача данных в событие**  
Используется стандартный шаблон с `EventArgs`:  
```csharp
public class MessageEventArgs : EventArgs {
    public string Text { get; }
    public MessageEventArgs(string text) => Text = text;
}

public event EventHandler<MessageEventArgs> MessageReceived;

// Вызов:
OnMessageReceived(new MessageEventArgs("Привет"));

// Защищённый метод-обёртка (по соглашению):
protected virtual void OnMessageReceived(MessageEventArgs e) =>
    MessageReceived?.Invoke(this, e);
```

**Пример простой:**
```csharp
class Button {
    public event Action Click;
    public void Press() => Click?.Invoke();
}

// Использование:
var btn = new Button();
btn.Click += () => Console.WriteLine("Нажато!");
btn.Press(); // → "Нажато!"
```

---

### **25. Стандартные делегаты и замыкания**

**25.1. `Action`, `Predicate`, `Func`**  
- `Action` — метод без возврата: `Action<int> a = x => Console.WriteLine(x);`  
- `Func<T, R>` — метод с возвратом: `Func<int, bool> f = x => x > 0;`  
- `Predicate<T>` — то же, что `Func<T, bool>` (используется в старых API, например `List.Find`).

**25.2. Что такое замыкание?**  
Когда лямбда или анонимный метод **захватывает переменную из внешней области видимости**.

**25.3. Применение замыкания**  
Позволяет «запомнить» состояние на момент создания лямбды.

**Пример замыкания:**
```csharp
int factor = 2;
Func<int, int> multiplier = x => x * factor; // захватил factor

Console.WriteLine(multiplier(5)); // 10

factor = 3;
Console.WriteLine(multiplier(5)); // 15 — использует текущее значение!
```

> ⚠️ Замыкание захватывает **переменную**, а не её значение на момент создания!

**Ещё пример (опасность):**
```csharp
var actions = new List<Action>();
for (int i = 0; i < 3; i++) {
    actions.Add(() => Console.WriteLine(i)); // все захватят одну и ту же i
}
// После цикла i = 3 → все выведут "3"
```

→ Решение: скопировать в локальную переменную:
```csharp
for (int i = 0; i < 3; i++) {
    int local = i;
    actions.Add(() => Console.WriteLine(local));
}
```

---


### **26. Интерфейсы**

**26.1. Что такое интерфейс?**  
Интерфейс — это **контракт**, описывающий, какие методы, свойства и события должен реализовать класс.  
Не содержит реализации (кроме реализаций по умолчанию, см. 26.3).

**26.2. Модификаторы доступа в интерфейсах**  
- Все члены интерфейса **неявно `public`**.  
- Указывать `public` можно, но не обязательно.  
- Другие модификаторы (`private`, `protected`) **нельзя** (до C# 8 — только публичные; с C# 8+ — можно `private`, `protected` для реализаций по умолчанию).

**26.3. Реализация по умолчанию**  
Начиная с C# 8, интерфейс может содержать **тело метода**:  
```csharp
interface ILogger {
    void Log(string msg) => Console.WriteLine($"[LOG] {msg}");
}
```
→ Класс может **не переопределять** такой метод.  
→ Полезно для обратной совместимости.

**Пример:**
```csharp
interface IDrawable {
    void Draw(); // без реализации — обязателен к реализации
    string Info => "Объект"; // свойство с реализацией по умолчанию
}

class Circle : IDrawable {
    public void Draw() => Console.WriteLine("Круг");
    // Info — используется из интерфейса
}
```

---

### **27. Применение интерфейсов**

**27.1. Множественная реализация интерфейсов**  
Класс может реализовывать **несколько интерфейсов**:  
```csharp
class Document : IReadable, IWritable { ... }
```

**27.2. Интерфейсы в преобразованиях типов**  
- **Восходящее**: `Document d = new Document(); IReadable r = d;` — безопасно.  
- **Нисходящее**: `IReadable r = GetDoc(); Document d = (Document)r;` — проверка через `is`/`as`.

**Явная реализация интерфейса**  
Используется, если два интерфейса имеют методы с одинаковыми именами:  
```csharp
interface IA { void M(); }
interface IB { void M(); }

class C : IA, IB {
    void IA.M() => Console.WriteLine("IA");
    void IB.M() => Console.WriteLine("IB");
}
```
→ Методы **доступны только через интерфейс**:  
```csharp
C c = new C();
// c.M(); // ошибка
((IA)c).M(); // OK
```
→ Явно реализованные члены **неявно `private`** — нельзя вызвать напрямую.

**Реализация в базовых и производных классах (4 варианта):**

1. **Базовый реализует, потомок не трогает** → используется реализация базового.  
2. **Базовый реализует, потомок переопределяет** → только если метод виртуальный или явная реализация заменена.  
3. **Базовый НЕ реализует (абстрактный)** → потомок обязан реализовать.  
4. **Интерфейс реализован и в базовом, и в потомке явно** → каждый работает со своим.

**Пример:**
```csharp
interface ILog { void Write(); }

abstract class Base : ILog {
    public virtual void Write() => Console.WriteLine("Base");
}

class Derived : Base {
    public override void Write() => Console.WriteLine("Derived");
}
```

---

### **28. Интерфейсы в обобщениях**

**28.1. Интерфейсы как ограничения обобщений**  
Гарантирует, что тип реализует нужный интерфейс:  
```csharp
void Process<T>(T item) where T : IComparable<T> {
    // можно вызывать item.CompareTo(...)
}
```

**28.2. Обобщённый интерфейс**  
Интерфейс с параметром типа:  
```csharp
interface IRepository<T> {
    T GetById(int id);
    void Save(T item);
}
```

**Особенности:**
- Можно наследовать интерфейсы:  
  ```csharp
  interface IReadRepository<T> : IRepository<T> { T GetById(int id); }
  ```
- При реализации указывается конкретный тип или остаётся обобщённым:  
  ```csharp
  class UserRepo : IRepository<User> { ... }
  class GenericRepo<T> : IRepository<T> { ... }
  ```

**Пример использования:**
```csharp
List<IComparable<int>> list = new List<IComparable<int>>();
list.Add(5); // int реализует IComparable<int>
```

> Интерфейсы + обобщения = гибкость и типобезопасность (например, коллекции, репозитории, стратегии).

---


### **29. Кортежи, анонимные типы, частичные классы**

#### **Кортежи (`Tuple` / `ValueTuple`)**

**29.1. Что такое кортеж?**  
Структура для хранения **нескольких значений разных типов** без создания отдельного класса.  
Синтаксис: `(int, string)`, можно с именами: `(int Id, string Name)`.

**29.2. Возврат кортежа из метода**  
```csharp
(int, string) GetInfo() => (42, "Alice");
// или с именами:
(Id: int, Name: string) GetInfo() => (42, "Alice");
```

**29.3. Передача кортежа в метод**  
```csharp
void Print((int, string) data) => Console.WriteLine($"{data.Item1}: {data.Item2}");
// или с именами:
void Print((int Id, string Name) data) => Console.WriteLine($"{data.Id}: {data.Name}");
```

> Кортежи — это `ValueTuple` (значимый тип), лёгкие и быстрые.

---

#### **Анонимные типы**  
Создаются через `new { ... }`, тип генерируется компилятором. Используются **только в пределах метода**.  
Пример:
```csharp
var person = new { Name = "Alice", Age = 30 };
```
→ Часто в LINQ:  
```csharp
var result = list.Select(x => new { x.Name, x.Age });
```

---

#### **Частичные классы и методы**  
- **Частичный класс (`partial class`)** — позволяет разделить определение класса на несколько файлов.  
  Используется в WinForms, WPF, генерируемом коде.  
  ```csharp
  partial class Form1 { ... }
  partial class Form1 { ... } // тот же класс
  ```

- **Частичный метод (`partial void M()`)** — объявляется в одном файле, может быть реализован в другом.  
  Если не реализован — компилятор удаляет вызовы.  
  Используется в генераторах кода.

---

### **30. Индексаторы**

**Что такое индексатор?**  
Позволяет обращаться к объекту **как к массиву**: `obj[index]`.

**Особенности:**
- Определяется через `this[...]`  
- Может иметь **несколько параметров**: `this[int row, int col]`  
- Может быть **перегружен** (разные сигнатуры)  
- Может иметь `get`/`set` с разными модификаторами доступа

**Пример:**
```csharp
class Matrix {
    private int[,] data = new int[3,3];

    public int this[int i, int j] {
        get => data[i, j];
        set => data[i, j] = value;
    }
}

// Использование:
var m = new Matrix();
m[0, 1] = 5;
Console.WriteLine(m[0, 1]); // 5
```

> Индексатор — это **свойство с параметрами**.

---

### **31. Неизменяемые типы (`record`)**

**Что такое `record`?**  
Специальный тип (класс или структура), предназначенный для **хранения данных**. По умолчанию **неизменяемый** и поддерживает **сравнение по значению**.

**Особенности:**
- Создаётся с помощью `record` (или `record struct`)  
- Поля инициализируются через **первичный конструктор** или **инициатор**  
- Поддерживает `with` для **копирования с изменением**  
- `Equals`, `GetHashCode`, `ToString` — генерируются автоматически

**Пример:**
```csharp
record Person(string Name, int Age);

var p1 = new Person("Alice", 30);
var p2 = p1 with { Age = 31 }; // копия с изменённым Age

Console.WriteLine(p1 == p2); // False — сравнение по значению!
```

> `record` — идеален для DTO, событий, иммутабельных моделей.

---
